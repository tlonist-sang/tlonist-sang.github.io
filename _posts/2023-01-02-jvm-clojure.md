---
layout: post
title: "Clojure로 JVM 공부하기"
date: 2023-01-02 23:00:57 +0900
categories: jekyll update
comments: true
---

JVM의 코드 실행

데이터 저장 장소
- heap : thread 간 공유
- stack : thread 별 생성
- local variable

JVM 스택머신 opcode는 1바이트로 표기
- 0~255까지 지정 가능. 그중 약 200개를 사용하고 있음.

플랫폼 초창기에는 클래스 파일 크기를 최대한 압축시키는게 중요한 설계 결정. 

간단한 JIT 튜닝법
- PrintComplication 스위치를 켜고 애플리케이션을 실행한다.
- 어느 메서드가 컴파일되었는지 기록된 로그를 수집한다.
- ReservedCodeCacheSize를 통해 코드 캐시를 늘린다.
- 애플리케이션을 재실행한다.
- 확장된 캐시에서 컴파일드 메서드를 살펴본다.

JIT 컴파일에 내재된 불확정성을 고려해야함.
- 캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 방향으로 커지는가?
- 주요 트랜잭션 경로상에 위치한 주요 메서드가 모두 컴파일되고 있는가?

JVM hotspot
- hotspot = name of JVM developed by Oracle


test는 sound 하지 complete 하지 않다


## 프로파일링

- 모니터링 툴/ 경고 시스템/ 프로파일러는 명확히 구분되어야 함.
- 프로파일링의 목표는 리팩터링 및 성능 최적화 대상 코드를 식별하는 것.
- 툴은 늘 어떤 수치를 내지만, 그 수치가 해결해야 할 문제와의 연관성은 확실히 알려주지 않음.
  

- 우수한 프로그래머는 핵심 코드를 주의깊게 잘 살펴봅니다. 하지만 그 전에 어떤 코드가 핵심 코드인지 식별합니다. -도널드 크누스-
- 프로파일링을 수행하기 전에 성능문제를 밝혀내야 함.

- CPU가 유저 모드에서 최고조에 달한 상태라면, 프로파일링을 하기 전에 GC STW 같은 요소는 원인 후보군에서 제외시켜야 함.
- 성능이 중요한 애플리케이션이면 GC 이벤트를 로깅하고 있기 때문에 간단히 확인 가능.
- 프로파일링에는 오버헤드가 존재한다.
- safepointing bias => 대부분의 샘플링이 안전한 공간에서만 발생함.
  - 모든 스레드는 샘플을 뜨기 전에 세이프포인트에 다다라야 한다.
  - 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링할 수 있다.
  - -XX:+PringtGCApplicationStoppedTime 로 세이프포인팅 시간이 높은 경우를 추적할 수 있음.
  - counted loop 문제. loop의 반복 횟수가 작으면 세이프포인트를 하지 않음.

- 힙 덤프 분석
  - 어떤 객체가 살아있는지, 그 개수와 타입은 어떤지 등의 중요한 팩트와 객체 그래프의 형상/구조를 파악할 수 있음.
  - 크기가 문제. 덤프한 메모리 크기의 300~400% 달하는 경우도 흔함.
